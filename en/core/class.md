#Class-based Component 

regularjs's OO implementation is modified from famous [|ded/klass|](https://github.com/ded/klass) which have one brilliant that you can simply using `this.supr` to call the parent's method with same method name


there are only two interfaces of klass are remained at regularjs, `extend` and `implement`.only the methods defined by these two interfaces have the ability to call `this.supr()`.


<a name="extend"></a>
### 1. `Component.extend(Object specification)`

`Component.extend` is used to define  SubComponent extended from Component，specification will merge to the SubComponent.


__the important part of sepecification__

1. __[AST|String] template__ : you can pass
  * a css selector point to the node contains template string

    if the browser doesnt support selector api. you can either rewirte the depended `Regular.dom.find` or only pass '#id' selector.
  * template string.
  * AST parsed from template(via `Regular.parse()`)

2. __[Function]   init()__: 
  
  initialize function. in this function, the dom structure is generated by `this.$compile`

  you can also bind the 'init' event.

  ```javascript
  this.$on('init', function(){...})
  ```

3. [Function]   config(data): 
  
  config is called before init when dom structure is not generated already.
  

4. [Function]   destroy: 

  custom cleaning logic goes here. make sure that you call the `this.supr()` to have the work done if you rewirte the `destroy()`.

  you can also bind the 'destroy' event to do the work.

  ```javascript
  this.$on('destroy', function(){...})
  ```

5. [String]     name: 

  component name. it makes the component [be nestable](../advanced/component.md) in other component(e.g. `<pager current={{current}}/>`)



Beacuse `Component.extend` 

由于extend同时又是组件定义的接口，所以在extend时，regularjs同时会做一些预处理操作:


1. 解析传入的template参数.
2. 从父类通过原型继承events, directive, filter, component等定义，使得可以访问到父类的定义，而新定义的指令,事件又不会影响到父类, 这种封闭性对于[regular的模块策略](../core/use.md)非常重要.
3. 如果有name的定义, 则为此组件注册组件名，使得可以以[内嵌组件](../advanced/component.md)的形式使用此组件


[DEMO: modal弹窗组件](http://fiddle.jshell.net/leeluolee/Xvp9S/)

<a name="implement"></a>
### 2. `Component.implement(Object specification)`

扩展组件的原型对象，sepecification与extend一致，扩展的方法同样可以使用`this.supr`

__Example__

```javascript
var Component = Regular.extend();


var component = new Component();

// add hello to prototype
Component.implement({
  hello: function(){}
})

component.hello();

```


<a name="instance"></a>

### 3.`new Component(Object specification)`

实例化组件

sepecification 与 `Component.extend`的specification结构一致，区别是这里传入的是添加为实例属性而不是在prototype上(即可以覆盖extend的声明)

例如, 初始化上例中的Modal组件

```javascript
var modal = new Modal({
  data: {title: '提示', content: '请确认提示'} 
})
modal.$on('confirm', function(){
  console.log('haha')
});
```

__实例化时传入的函数无法调用`this.supr()`__



---------------

